\documentclass[10pt]{article}

\usepackage{times,graphicx,epstopdf,fancyhdr,amsfonts,amsthm,amsmath,algorithm,algorithmic,xspace,hyperref}
\usepackage[left=1in,top=1in,right=1in,bottom=1in]{geometry}

%\textwidth 7in
%\textheight 9.5in


\pagestyle{fancy}

\lhead{Spring 2018}
\chead{CS256: Algorithm Design and Analysis}
\rhead{Assignment 3}
\lfoot{Instructor: Bill Lenhart}
\rfoot{Due:  11.00pm, 1 March}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headwidth}{\textwidth}
%\renewcommand{\footwidth}{\textwidth}
%\addtolength{\headwidth}{\marginparwidth}
%\addtolength{\headwidth}{\marginparsep}
\renewcommand{\footrulewidth}{0.4pt}

\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{observation}{Observation}
\newtheorem{question}{Question}

\setlength\parindent{0pt}

\begin{document}

\section*{Greed is Good\footnote{Gordon Gekko, \emph{Wall Street}}}

\subsection*{Reminders}

\vspace{5pt}

\textbf{When asked to design an algorithm, always assume that you need to prove its correctness and analyze its
time and space requirements.}

\subsection*{Algorithms in the Wild}

\begin{question}{String Pattern-Matching}
Let $\Sigma$ be a finite alphabet (evocative synonym for 'set') and let $w = \tau_1 \tau_2 \ldots  \tau_m$ and $p = \sigma_1 \sigma_2 \ldots \sigma_n$
be two finite sequences of elements of $\Sigma$.\footnote{Tradition: Greek letters are used when denoting alphabets and their ``letters".}  We say that the word $w$ {\em contains} the pattern $p$ if $\sigma_1, \sigma_2,\ldots,  \sigma_n$
occur in $w$ in the same order (but not necessarily consecutively) that they occur in $p$.   That is, $w$ contains $p$ if for some
$\tau_{i_1}, \ldots , \tau_{i_n}$ with $i_1 < i_2 < \ldots < i_n$ we have $\tau_{i_1} = \sigma_1, \ldots , \tau_{i_n} = \sigma_n$.
Design an $O(n+m)$ (greedy) algorithm to determine, given a pair $w$ and $p$, whether $w$ contains the pattern $p$, and prove that your
algorithm correctly solves the problem in this amount of time.
\end{question}

\begin{question}{The Circle Game}

Please answer Question 17 from Chapter 4 of your text.  Try to shoot for an $O(n^2)$ algorithm; it's a bit of a challenge to beat that (although if you're feeling really ambitious, $O(n \log n)$ time is possible...).
\end{question}

\subsection*{Spanning Tree Applications}

\begin{question} \label{q:fes}
A {\em feedback edge set} of a graph $G$ is a subset $F$ of the edges such that every cycle in $G$ contains at least one edge in $F$. In other words, removing every edge in $F$ makes the graph $G$ acyclic.   Describe and analyze a fast algorithm to compute the minimum weight feedback edge set of  a given edge-weighted graph.  Hint.  Relate this problem to some kind of spanning tree problem.
\end{question}

\begin{question}
In many situations, you might find yourself dealing with a dynamically changing data structure.  One such simple example is that of
dynamically changing edge weights in a graph.  This problem asks you to consider how you would maintain a minimum-cost spanning tree in
such an environment.

Suppose you are given a graph $G$ with weighted edges and a minimum spanning tree $T$ of $G$. 
\begin{description}
 	\item [(a)] Describe and analyze an algorithm to update the minimum spanning tree when the weight of a single edge $e$ is decreased.
	\item [(b)] Describe and analyze an  algorithm to update the minimum spanning tree when the weight of a single edge $e$ is increased.
\end{description}
In both cases, the input to your algorithm is the edge $e$ and its new weight; your algorithms should modify $T$ so that it is still a minimum spanning tree.  {\em Hint:  consider $e \in T$ and $e \not\in T$ separately}.
\end{question}

\subsection*{Theory vs Practice}

\textbf{You need only hand in a solution to one of the two questions below.}  However, you are strongly encouraged to give some thought to both of them! In particular, the Euler tour concept is likely to reappear at some later point in the semester.

\begin{question}
An Euler\footnote{Named after Leonhard Euler (1707-1783) who solved part (a) in 1735}
 tour of a graph $G$ is a circuit (that is, a path that begins and ends at the same vertex), through $G$ that traverses every edge of $G$ exactly once. 
\begin{description}
	\item [(a)] Prove that a connected graph $G$ has an Euler tour if and only if every vertex has even degree. 
	\item [(b)] Describe and analyze a linear time algorithm to compute an Euler tour in a given graph, or correctly 
report that no such tour exists. 
\end{description}
\end{question}

\begin{question}[maze generation]
Kruskal's and Prim's algorithms take some effort to analyze for correctness, but both are conceptually simple and easy to program.
They can also be applied in some unusual ways, such as for maze generation.
There's a cute Wikipedia entry on the topic:
\begin{verbatim}
http://en.wikipedia.org/wiki/Maze_generation_algorithm
\end{verbatim}
Read the sections about randomized Kruskal's and randomized Prim's algorithms and implement a maze generation program using one of the algorithms.  Your program should take two parameters, an integer width $w$ and an integer height $h$, and should generate a reasonable
visualization of a $w$ by $h$ maze.  The visualization needn't be fancy: anything from popping up a window on the screen to saving the maze
as a grid of x's and o's (in some uniform width font!) should be fine.
However, I must be able to run it easily on the departmental  unix machines, and it should be written in either Java (a language I know), C or C++ (languages I used to know when I was a boy), or Python (a language I'd like to know better).
Solutions should be submitted via the {\em turnin} command.
\end{question}

\end{document}
